# ğŸ”§ å¹¶å‘å·¥å…·ç±»

## å¹¶å‘å·¥å…·ç±»æ¦‚è¿°

Java 5 å¼•å…¥çš„ `java.util.concurrent` åŒ…æä¾›äº†ä¸°å¯Œçš„å¹¶å‘å·¥å…·ç±»ï¼Œç®€åŒ–å¤šçº¿ç¨‹ç¼–ç¨‹ã€‚

## ExecutorService

### çº¿ç¨‹æ± 

```java
// åˆ›å»ºçº¿ç¨‹æ± 
ExecutorService executor = Executors.newFixedThreadPool(5);

// æäº¤ä»»åŠ¡
executor.submit(() -> {
    System.out.println("ä»»åŠ¡æ‰§è¡Œ");
});

// å…³é—­çº¿ç¨‹æ± 
executor.shutdown();
```

### å¸¸ç”¨çº¿ç¨‹æ± ç±»å‹

```java
// å›ºå®šå¤§å°çº¿ç¨‹æ± 
ExecutorService fixedPool = Executors.newFixedThreadPool(5);

// å•çº¿ç¨‹æ± 
ExecutorService singlePool = Executors.newSingleThreadExecutor();

// ç¼“å­˜çº¿ç¨‹æ± 
ExecutorService cachedPool = Executors.newCachedThreadPool();

// å®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± 
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(5);
```

### çº¿ç¨‹æ± æœ€ä½³å®è·µï¼ˆæ›¿ä»£ Executors é»˜è®¤ï¼‰

```java
ThreadPoolExecutor ioPool = new ThreadPoolExecutor(
    16, 64,
    60, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(10_000),
    new ThreadFactoryBuilder().setNameFormat("io-pool-%d").build(),
    new ThreadPoolExecutor.CallerRunsPolicy()
);
```

- å‘½åçº¿ç¨‹ä¾¿äºæ’éšœï¼›åˆç†é˜Ÿåˆ—å®¹é‡ä¸æ‹’ç»ç­–ç•¥ï¼Œé¿å… OOM ä¸ä»»åŠ¡ä¸¢å¤±ã€‚

## Future å’Œ Callable

```java
// ä½¿ç”¨ Callable æäº¤ä»»åŠ¡
ExecutorService executor = Executors.newFixedThreadPool(5);

Future<Integer> future = executor.submit(() -> {
    Thread.sleep(1000);
    return 42;
});

// è·å–ç»“æœ
try {
    Integer result = future.get();  // é˜»å¡ç­‰å¾…ç»“æœ
    System.out.println("ç»“æœ: " + result);
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}
```

## CompletableFutureï¼ˆè¿›é˜¶ï¼‰

```java
CompletableFuture<String> user = CompletableFuture.supplyAsync(() -> getUser());
CompletableFuture<List<Order>> orders = CompletableFuture.supplyAsync(() -> getOrders());

String result = user.thenCombine(orders, (u, os) -> render(u, os))
    .orTimeout(500, TimeUnit.MILLISECONDS)
    .exceptionally(ex -> "fallback")
    .join();
```

- ç»„åˆ/èšåˆ/å¼‚å¸¸é“¾è·¯ä¸è¶…æ—¶æ§åˆ¶ï¼›`allOf/anyOf` æ”¯æŒå¹¶å‘èšåˆã€‚

## CountDownLatch

```java
// å€’è®¡æ—¶é—¨é—©
CountDownLatch latch = new CountDownLatch(3);

// å¤šä¸ªçº¿ç¨‹
for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        // æ‰§è¡Œä»»åŠ¡
        latch.countDown();  // è®¡æ•°å‡1
    }).start();
}

// ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
latch.await();
System.out.println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ");
```

## CyclicBarrier

```java
// å¾ªç¯å±éšœ
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    System.out.println("æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾å±éšœ");
});

// å¤šä¸ªçº¿ç¨‹
for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        try {
            // æ‰§è¡Œä»»åŠ¡
            barrier.await();  // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    }).start();
}
```

## Semaphore

```java
// ä¿¡å·é‡
Semaphore semaphore = new Semaphore(3);  // æœ€å¤š3ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®

// å¤šä¸ªçº¿ç¨‹
for (int i = 0; i < 10; i++) {
    new Thread(() -> {
        try {
            semaphore.acquire();  // è·å–è®¸å¯
            // æ‰§è¡Œä»»åŠ¡
            semaphore.release();  // é‡Šæ”¾è®¸å¯
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
}
```

## Phaserï¼ˆé˜¶æ®µåŒæ­¥å™¨ï¼‰

```java
Phaser phaser = new Phaser(1); // æ³¨å†Œä¸»çº¿ç¨‹
for (int i = 0; i < 3; i++) {
    phaser.register();
    int phaseNo = i;
    new Thread(() -> {
        // é˜¶æ®µ1
        phaser.arriveAndAwaitAdvance();
        // é˜¶æ®µ2
        phaser.arriveAndAwaitAdvance();
        phaser.arriveAndDeregister();
    }, "t-" + phaseNo).start();
}
phaser.arriveAndDeregister(); // é‡Šæ”¾ä¸»çº¿ç¨‹
```

## Exchangerï¼ˆæ•°æ®äº¤æ¢ï¼‰

```java
Exchanger<String> exchanger = new Exchanger<>();
new Thread(() -> {
    try { exchanger.exchange("A"); } catch (InterruptedException ignored) {}
}).start();
new Thread(() -> {
    try { String v = exchanger.exchange("B"); } catch (InterruptedException ignored) {}
}).start();
```

## å¹¶å‘é›†åˆä¸ç´¯åŠ å™¨

```java
ConcurrentHashMap<String, Long> map = new ConcurrentHashMap<>();
map.merge("k", 1L, Long::sum);

LongAdder adder = new LongAdder();
adder.increment();
long sum = adder.sum();
```

## é”ä¸åŒæ­¥å™¨ï¼ˆLock/StampedLock æ¦‚è§ˆï¼‰

- `ReentrantLock`ï¼šå¯ä¸­æ–­ã€å…¬å¹³é”ã€æ¡ä»¶é˜Ÿåˆ—ï¼›
- `ReentrantReadWriteLock`ï¼šè¯»å¤šå†™å°‘ï¼›
- `StampedLock`ï¼šä¹è§‚è¯»ï¼Œéœ€æ ¡éªŒæˆ³ï¼›ä¸æ”¯æŒé‡å…¥ä¸æ¡ä»¶å˜é‡ã€‚

```java
StampedLock lock = new StampedLock();
long stamp = lock.tryOptimisticRead();
int v = data;
if (!lock.validate(stamp)) {
    stamp = lock.readLock();
    try { v = data; } finally { lock.unlockRead(stamp); }
}
```

## ForkJoin ä¸å¹¶è¡Œè®¡ç®—

```java
class SumTask extends RecursiveTask<Long> {
    final long[] arr; final int lo, hi;
    SumTask(long[] a, int l, int h) { arr=a; lo=l; hi=h; }
    protected Long compute() {
        if (hi - lo <= 10_000) {
            long s=0; for (int i=lo;i<hi;i++) s+=arr[i]; return s;
        }
        int mid = (lo + hi) >>> 1;
        SumTask left = new SumTask(arr, lo, mid);
        SumTask right = new SumTask(arr, mid, hi);
        left.fork();
        long r = right.compute() + left.join();
        return r;
    }
}
```

## RateLimiterï¼ˆGuava æ‰©å±•ï¼‰ä¸é™æµæ€è·¯

```java
RateLimiter limiter = RateLimiter.create(100.0); // æ¯ç§’100ä¸ªè®¸å¯
limiter.acquire(); // è·å–1ä¸ªè®¸å¯
```

- é™æµå¸¸ä¸é˜Ÿåˆ—/æ‹’ç»ç­–ç•¥/é™çº§ç»“åˆï¼Œä¿éšœç³»ç»Ÿç¨³æ€ã€‚

## ä¸‹ä¸€æ­¥

æŒæ¡äº†å¹¶å‘å·¥å…·ç±»åï¼Œå¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

- [JVM åŸºç¡€](/java/20-JVMåŸºç¡€.md) - å­¦ä¹  JVM åŸç†
- [Java 8+ æ–°ç‰¹æ€§](/java/21-Java8+æ–°ç‰¹æ€§.md) - å­¦ä¹  Java æ–°ç‰¹æ€§

---

<div style="text-align: center; margin-top: 2rem;">
  <p>ğŸ’¡ <strong>æç¤º</strong>ï¼šå¹¶å‘å·¥å…·ç±»æä¾›äº†æ›´é«˜çº§çš„å¹¶å‘æ§åˆ¶ï¼Œåˆç†ä½¿ç”¨å¯ä»¥æé«˜ç¨‹åºæ€§èƒ½</p>
</div>
